/*  This file is part of GeckoCIRCUITS. Copyright (C) ETH Zurich, Gecko-Simulations AG
 *
 *  GeckoCIRCUITS is free software: you can redistribute it and/or modify it under 
 *  the terms of the GNU General Public License as published by the Free Software 
 *  Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *  GeckoCIRCUITS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 *  PURPOSE.  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 *  GeckoCIRCUITS.  If not, see <http://www.gnu.org/licenses/>.
 */
package ch.technokrat.gecko.geckocircuits.control;

import ch.technokrat.gecko.GeckoExternal;
import ch.technokrat.gecko.GeckoSim;
import ch.technokrat.gecko.geckocircuits.allg.FormatJTextField;
import ch.technokrat.gecko.geckocircuits.allg.UserParameter;
import ch.technokrat.gecko.geckocircuits.circuit.ControlSourceType;
import ch.technokrat.gecko.geckocircuits.control.calculators.AbstractControlCalculatable;
import ch.technokrat.gecko.geckocircuits.control.calculators.SmallSignalCalculator;
import ch.technokrat.gecko.geckocircuits.datacontainer.DataContainerSimple;
import ch.technokrat.gecko.geckocircuits.newscope.BodePlot2;
import ch.technokrat.gecko.geckocircuits.newscope.GeckoSymbol;
import ch.technokrat.gecko.geckocircuits.newscope.GraferV4;
import ch.technokrat.gecko.geckocircuits.newscope.NiceScale;
import ch.technokrat.gecko.geckocircuits.newscope.ScopeSettings;
import ch.technokrat.gecko.geckocircuits.newscope.SimpleGraferPanel;
import ch.technokrat.gecko.i18n.GuiFabric;
import ch.technokrat.gecko.i18n.resources.I18nKeys;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerModel;
import javax.swing.border.TitledBorder;

public class DialogSmallSignalAnalysis extends DialogElementCONTROL<ReglerSmallSignalAnalysis> {

    private JComboBox<SSAShape> _jComboSignal;
    private GraferV4 _grafer;
    private SimpleGraferPanel newScope1;
    private double oldTend;
    private BodePlot2 _bodePlot;

    /**
     * Creates new form DialogSmallSignalAnalysis2
     */
    public DialogSmallSignalAnalysis(final ReglerSmallSignalAnalysis parent) {
        super(parent);
        initComponents();
        //jPanelBode.add(new BodePlot2());
        this.setResizable(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 890, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 589, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void setResizable(boolean resizable) {
        super.setResizable(true);
    }

    @Override
    public void baueGUI() {
        this.setLocationRelativeTo(GeckoSim._win);
        jPanelName.setLayout(new GridLayout(1, 5));
        con = this.getContentPane();
        con.setLayout(new BorderLayout());
        try {

            JPanel namePanel2 = new JPanel();
            namePanel2.setBorder(new TitledBorder("Component properties"));
            namePanel2.setLayout(new BorderLayout());
            namePanel2.add(jPanelName, BorderLayout.WEST);

            con.add(namePanel2, BorderLayout.NORTH);
        } catch (Exception ex) {
            // sometimes, I git an XException here... don't know the reason.
            ex.printStackTrace();
        }

        _bodePlot = new BodePlot2();

        if (element.getControlCalculatable() != null) {
            SmallSignalCalculator ssc = (SmallSignalCalculator) element.getControlCalculatable();
            _bodePlot.insertData(ssc._bode);
        }

        _bodePlot.setMinimumSize(new Dimension(300, 300));
        _bodePlot.setPreferredSize(new Dimension(600, 600));

        //_bodePlot._graferNew._manager.getDiagrams().get(0).getCurve(0).setSymbolEnabled(false);
        con.add(_bodePlot, BorderLayout.CENTER);

        jpM.setLayout(new GridLayout(8, 1));
        jpM.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),
                "Parameter", TitledBorder.LEFT, TitledBorder.TOP));

        _jComboSignal = new JComboBox<SSAShape>(SSAShape.values());
        _jComboSignal.setSelectedItem(element._signalType.getValue());
        _jComboSignal.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(final ActionEvent actionEvent) {
                element._signalType.setUserValue((SSAShape) _jComboSignal.getSelectedItem());

            }
        });

        baueGuiIndividual();

        ScopeSettings settings = new ScopeSettings();
        _grafer = new GraferV4(settings);
        _grafer.createInitialAndSingleDiagram(false, false, 2);
        _grafer._manager.getDiagrams().get(0).getCurve(0).setSymbolEnabled(false);
        _grafer._manager.getDiagrams().get(0).getLabelPanel().setVisible(false);

        JPanel westPanel = new JPanel();
        westPanel.setLayout(new BorderLayout());
        westPanel.add(jpM, BorderLayout.NORTH);

        _grafer.setMinimumSize(new Dimension(300, 300));
        _grafer.setPreferredSize(new Dimension(300, 300));

        JPanel previewPanel = new JPanel();
        previewPanel.setBorder(new TitledBorder("Small Signal Excitation Preview:"));
        previewPanel.setLayout(new BorderLayout());

        newScope1 = new SimpleGraferPanel(_grafer);

        previewPanel.add(newScope1);
        westPanel.add(previewPanel, BorderLayout.CENTER);

        con.add(westPanel, BorderLayout.WEST);
        con.add(jPanelButtonOkCancel, BorderLayout.SOUTH);

        this.getRootPane().setDefaultButton(null);
        updatePlot();

    }

    @Override
    public JPanel createParameterPanel(UserParameter<? extends Number>... parameters) {
        JPanel returnValue = super.createParameterPanel(parameters); //To change body of generated methods, choose Tools | Templates.
        Object formatField = returnValue.getComponent(1);
        if (formatField instanceof FormatJTextField) {
            final FormatJTextField ff = (FormatJTextField) formatField;

            ff.addFocusListener(new FocusAdapter() {
                @Override
                public void focusLost(FocusEvent e) {
                    super.focusLost(e); //To change body of generated methods, choose Tools | Templates.
                    processRegisteredParameters();
                    updatePlot();
                }

            });
        }
        return returnValue;
    }

    private void updatePlot() {


        double lowFreq = element._fBase.getValue();
        
        double T = 1.0 / lowFreq;

        
        SmallSignalCalculator ssc = element._lastCalculator;
        if(ssc == null) return;
        double[] ssv = ssc._smallSignalValues;
        double[] measuredValues = ssc._measuredValues;
        double dt = ssc._calculationDeltaT;
        
        System.out.println("number of valid samples " + ssc._numberSamples + " " + ssc._N);
                        
        double time = 0;
        
        DataContainerSimple dcs1 = DataContainerSimple.fabricArrayTimeSeries(2, ssv.length);
        
        
        
        int cIndex = ssc.circularIndex;
        int NN = ssv.length;
        
        for(int i = 0; i < NN; i++) {
            dcs1.insertValuesAtEnd(new float[]{(float) ssv[cIndex], (float) measuredValues[cIndex]}, time);            
            time += dt;
            cIndex++;
            if(cIndex == NN) {
                cIndex = 0;
            }
        }

        

//        for (int i = 0; i < data[0].length; i++) {
//            dcs1.insertValuesAtEnd(new float[]{(float) data[1][i], (float) data[2][i]}, data[0][i]);
//        }

        double Tnice = NiceScale.niceNum(T, true);
        _grafer.setSimulationTimeBoundaries(0, Tnice);
        _grafer._manager.getDiagrams().get(0).getCurve(1).setSymbolEnabled(false);
        //dcs1.setContainerStatus(ContainerStatus.PAUSED);

        _grafer.setDataContainer(dcs1);
        dcs1.setSignalName("1", 0);
    }

    @Override
    void baueGuiIndividual() {        
        
        JPanel pAmpl = createParameterPanel(element._amplitude);
        jpM.add(pAmpl, BorderLayout.CENTER);

        JPanel pLowFreq = createParameterPanel(element._fBase);
        jpM.add(pLowFreq, BorderLayout.CENTER);

        JPanel pHighFreq = createParameterPanel(element._fMax);
        jpM.add(pHighFreq, BorderLayout.CENTER);

        jpM.add(new JLabel("Small Signal Shape:"), BorderLayout.CENTER);
        jpM.add(_jComboSignal);

        final JCheckBox jCheckBoxAddOutput = new JCheckBox("Internally adding signal to output");
        jCheckBoxAddOutput.setSelected(element._doAddOutput.getValue());

        jpM.add(jCheckBoxAddOutput);
        jCheckBoxAddOutput.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                element._doAddOutput.setUserValue(jCheckBoxAddOutput.isSelected());
            }
        });

                
    }

    private void runCalculation() {
        oldTend = GeckoExternal.get_Tend();
        GeckoExternal.set_Tend(GeckoExternal.getSimulationTime() + 1.0 / element._fBase.getValue());
        GeckoExternal.continueSimulation();

        GeckoExternal.set_Tend(oldTend);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
